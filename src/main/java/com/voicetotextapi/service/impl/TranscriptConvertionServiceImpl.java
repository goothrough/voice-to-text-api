package com.voicetotextapi.service.impl;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Date;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.voicetotextapi.exception.CustomException;
import com.voicetotextapi.repository.SpeechRecordsRepository;
import com.voicetotextapi.repository.entity.SpeechRecord;
import com.voicetotextapi.service.TranscriptConvertionService;
import com.voicetotextapi.service.dto.TranscriptConvertionServiceInDto;
import com.voicetotextapi.service.dto.TranscriptConvertionServiceOutDto;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TranscriptConvertionServiceImpl implements TranscriptConvertionService {

	@Value("${witai.url}")
	private String WIT_AI_API_URL;
	@Value("${witai.accesstoken}")
	private String WIT_AI_ACCESS_TOKEN;
	private final SpeechRecordsRepository repository;

	@Override
	public TranscriptConvertionServiceOutDto convertAudioDataToTranscript(
			TranscriptConvertionServiceInDto serviceInDto) {

		try {
			// Convert reqeusted file to bytes
			byte[] audioData = serviceInDto.getAudiofile().getBytes();

			// Request to Wit.ai
			ResponseEntity<Resource> response = sendRequestToWitAi(audioData);

			if (response.getStatusCode() == HttpStatus.OK) {
				InputStream inputStream = response.getBody().getInputStream();
				BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
				String previousLine = null;
				String currentLine;
				while ((currentLine = reader.readLine()) != null) {
					// Find the final transcript generated by Wit.ai
					if (currentLine.contains("FINAL_TRANSCRIPTION")) {
						break;
					}
					previousLine = currentLine;
				}

				String transcriptValue = getTranscriptValueFromPlainText(previousLine);
				if (transcriptValue.isEmpty() || transcriptValue == null) {
					throw new CustomException(
							"A transcript could not be created. The audio may have been empty. Please try again.");
				}
				// Save to Database
				SpeechRecord speechRecord = new SpeechRecord();
				speechRecord.setTranscript(transcriptValue);
				Date currentDate = new Date();
				speechRecord.setCreatedAt(currentDate);
				speechRecord.setUpdatedAt(currentDate);
				repository.save(speechRecord);

				TranscriptConvertionServiceOutDto serviceOutDto = new TranscriptConvertionServiceOutDto();
				serviceOutDto.setTranscript(transcriptValue);

				return serviceOutDto;

			} else {
				// Response status isn't OK
				throw new CustomException("The response status was not OK. Please try again later.");
			}

		} catch (JsonProcessingException e) {
			// Error during parsing text to Json
			e.printStackTrace();
			throw new CustomException("Something went wrong while processing response. Please try again later.");
		} catch (IOException e) {
			// Error during converting requested file to bytes
			// Error during getting inputstream from the response body
			// Error during reading text of inputstream
			e.printStackTrace();
			throw new CustomException("Something went wrong while getting response. Please try again later.");
		} catch (CustomException e) {
			e.printStackTrace();
			throw new CustomException(e.getMessage());
		}

	}

	/**
	 * Send a request to Wit.ai
	 * @param audioData
	 * @return
	 */
	private ResponseEntity<Resource> sendRequestToWitAi(byte[] audioData) {
		RestTemplate restTemplate = new RestTemplate();

		// Header settings
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.parseMediaType("audio/wav"));
		headers.set("Authorization", "Bearer " + WIT_AI_ACCESS_TOKEN);
		headers.set("Transfer-encoding", "chunked");

		// Set the audio data to the body of the request
		ByteArrayResource resource = new ByteArrayResource(audioData);
		HttpEntity<ByteArrayResource> requestEntity = new HttpEntity<>(resource, headers);

		// Send a request to Wit.ai
		return restTemplate.exchange(
				WIT_AI_API_URL,
				HttpMethod.POST,
				requestEntity,
				Resource.class);
	}

	/**
	 * Parse plain text to Json, and extract the transcript value.
	 * @param readText
	 * @return String transcript value extracted from the plain text
	 * @throws JsonMappingException
	 * @throws JsonProcessingException
	 */
	private String getTranscriptValueFromPlainText(String readText)
			throws JsonMappingException, JsonProcessingException {
		readText = readText.substring(0, readText.length() - 1);
		String fixedJson = "{" + readText + "}";
		ObjectMapper objectMapper = new ObjectMapper();
		JsonNode jsonNode = objectMapper.readTree(fixedJson);
		return jsonNode.get("text").asText();
	}

}
